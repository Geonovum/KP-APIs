

| Onderdeel  | Opmerking | Status| Verwerking - Afhandeling |
| ------------- | ------------- |--|--|
|5.3.3.12 |Identificatie is niet alleen relevant voor (eind)gebruikers, maar ook voor applicaties en de organisaties die deze applicaties hebben geregistreerd. Dat opent de weg naar policies per applicatie/organisatie. Overigens heeft niet iedere API consumer een gebruiker geauthenticeerd - er zijn immers tal van back-office en batchprocessen die niet in de context van een eindgebruiker werken (maar wel API's kunnen aanroepen).In een keten van API's (b.v. van mijnOverheid naar Generieke Service, naar Berichtenmagazijn) is identity propagation relevant. Het zou erg welkom zijn als hiervoor een kader wordt geschetst. | | |
|5.3.13|Een simpele vorm van autorisatie is door identity injection. Stel, een system API heeft een {bsn} als parameter. Door deze te publiceren als onderdeel van een /mijn API kan de parameter in de frontend vervallen, en op de gateway vanuit een JWT of SAML assertion toegevoegd worden. Daarmee is het gebruik van de system API in de context van de stakeholder API ingekaderd. Bijkomend voordeel is dat de persoonsgebonden informatie in een token versleuteld over het netwerk gaat.Dezelfde truc werkt voor alternatieve identiteiten, zoals de OIN van afnemers of de RSIN van bedrijven. |  |  |
|5.3.3.x|Ik mis een strategie voor een digitale handtekening als onderdeel van een API aanroep (RFC 7515).|  |  |
|5.3.2.5|Ook/juist voor API's die organisatie-overstijgend zijn (b.v. het proces van een omgevingsvergunning) is een goede governance cruciaal. Bedenk dat een API die vanuit de afnemer/doelgroep wordt gedefinieerd vaak organisatie-overstijgend is|  |  |
|5.5.3|Een resourcemodel is wezenlijk meer dan een datamodel, het is eerder vergelijkbaar met een domeinmodel. Denk alleen maar aan het CQRS patroon, waarbij een "command" voor een resource op een andere locatie wordt afgehandeld dan de corresponderende "query". Maar er is veel meer. Gegeven de stapeling van verschillende API's (system, proces, experience), is het gedrag soms ook verschillend. Bijvoorbeeld: bij een GET van een bericht in een berichtenmagazijn vanuit een burger wordt een bericht gemarkeerd als "opgevraagd", terwijl dezelfde GET bij het opvragen door een afnemer of een beheerder (b.v ten behoeve van de migratie) zich anders gedraagt.Met andere woorden, dezelfde resource wordt via verschillende paden ontsloten en gedraagt zich anders naar gelang de context.Het is ook zeker niet zo dat een resource model alleen op technisch niveau gemodelleerd kan worden. Denk maar weer aan CQRS -- logisch is het één resource, fysiek zijn het er meerdere. Denk ook aan versies: logisch is er alleen de default versie, technisch zijn er (op sommige momenten) verschillende versies parallel actief.|  | Resource model als Domeinmodel met zowel data als 'command' elementen is optie om op te nemen in een volgende versie, de huidige versie heeft een data invalshoek |
|5.6|Ik mis een paragraaf voor het 'tamper-proof' maken van API's, ook wel bekend als API Hardening.Een liberale definitie van een API nodigt uit tot allerlei vormen van misbruik, terwijl bij een goed uitgespecificeerde interfacedefinitie zaken als SQL injection of Custom Special Character Injection kunnen worden tegengegaan (met een simpele schema validatie).Denk aan:* iedere string wordt gedefinieerd met een maximale lengte.* iedere string wordt gedefinieerd met een regular expression* iedere array wordt gedefinieerd met een maximum aantal rijen* iedere datum wordt gedefinieerd met een geldig bereik* etc|  |  |
|5.2.1|Er is een inherent probleem in het onderscheid tussen intern en extern, en dat is dat het gedurende de levenscyclus van een API kan veranderen. Een API die is gebouwd voor een eigen website (intern DNS) wordt later ingebouwd in een mobiele app (publiek DNS). En dan heb ik het nog niet over de gevallen waar de beveiliging van de website wordt omzeild.Het is beter om er in alle gevallen van uit te gaan dat een API inherent veilig moet zijn, en nooit te vertrouwen op enige client-side logica.Er is wel een zinvol onderscheid te maken in termen van audience. Is het gericht op insiders, dan kan er veel meer voorkennis worden voorondersteld dan bij outsiders. Insiders hebben domeinkennis, outsiders niet. Dat hoeft niet samen te gaan met het technische onderscheid intern/extern. Insiders kunnen bijvoorbeeld ook ketenpartners zijn, en outsiders kunnen collega's van een andere afdeling zijn.|  |  |
|5.2.2|Ik heb al eerder opgemerkt dat een onderscheid tussen een "stakeholder-centric" API en een "process-centric" API zinvol is. Dit vooronderstelt wel dat de overlap goed wordt gemanaged.Een process API doet in mijn ogen echter niet noodzakelijkerwijs aan orkestratie (daar zijn betere technieken voor), het is slechts een bundeling van operaties voor de afhandeling van een zaak.Een Stakeholder API is er ook niet voor één gebruikersvraag. In tegendeel. Het is eerder het ene loket dat een stakeholder nodig heeft om al zijn zaken met een partij (in casu: de overheid) af te handelen. Wederom is de analogie met een website treffend. Je wilt niet voor iedere vraag naar aan andere website moeten zoeken, maar één plek ('mijnOverheid') voor alles.|  | "stakeholder-centric" API komt goed overeen met : Convenience of Experience API (beantwoord één specifieke gebruikersvraag) -  van één kan 'een' worden gemaakt |
|5.2.6|Deze paragraaf verdient meer diepgang. Bijvoorbeeld ook in relatie tot §5.2.1. Denk aan een GraphQL API die geschikt is voor insiders, terwijl een hypermedia stijl juist past in een microservice architectuur (net als gRPC/AVRO en Kafka). OpenAPI heeft veel tractie in de markt, terwijl dat voor AsyncAPI nog op gang moet komen.Ook zinvol is het onderscheid tussen een "managed API" (policy enforcement vanuit de omgeving) en een unmanaged API (geen controle vanuit de omgeving). Binaire protocollen zoals gRPC hebben wat dat betreft andere karakteristieken en mogelijkheden dan sterk gestandaardiseerde berichten conform OpenAPI of AsyncAPI. Deze standaardisatie leent zich immers voor een "preprocessor" die alle berichten kan uitfilteren die niet aan de regels voldoen. Dit is overigens een veel effectievere manier van beveiligen dan met een web application firewall mogelijk is, maar dat terzijde.|  | Kan in een volgende versie worden meeenomen |
|5.3|In dit overzicht mis ik een aantal capabilities, zoals API product/portfolio management, contract management, platform lifecycle management (selectie, implementatie, updates, upgrades) en community-interactie (aankondigingen, verzoeken,  bug reports, etc).De naam "ontwikkelaar onboarding" is ongelukkig gekozen. Het suggereert voor mij dat API Management een techneuten aangelegenheid is, terwijl het in feite een "product" is dat wordt aangeboden en verworven. Waarom niet gekozen voor een neutralere term, b.v. afnemerbeheer? En moet er dan trouwens ook geen "leveranciersbeheer" zijn?|  |  |
|5.3.1.2|Let bij het registreren van de applicatie ook op de gekozen grant types. Meestal is het beter om een API te splitsen als er meerdere grant types worden ondersteund. Over het algemeen hebben die verschillende soorten grants namelijk een verschillend doel waar verschillende policies bijpassen. Als er bij het registreren van een applicatie kan worden gekozen, dan is een controle op de juistheid op z'n plaats.|  |  |
|5.3.2.7|Versionering van API's is in de praktijk veel belangrijker dan velen zich realiseren. Het aanbieden van meerdere versies tegelijkertijd maakt parallelle ontwikkeling mogelijk, ook co-creatie buiten de eigen organisatie, en maakt het mogelijk dat sommige early adopters voorlopen op het peloton. Daarmee is het de sleutel tot een soepel evoluerende keten, waarbij het absorberen van wijzigingen een routine wordt.Bij versionering is het goed om een aantal zaken scherp te scheiden1\. De werking van de API op business niveau: welke dienst wordt er geboden tegen welke service levels (inclusief quota)?2\. De interfacespecificatie -- het technische berichtformaat van aanroepen en responses (inclusief zaken als regular expressions, geldige waardenbereiken, min/max occurrences, etc)3\. De API policies - b.v. autorisatie-eisen, burst protection, content negotiation4\. De werking van de implementatie (sortering, aanvullende (plausibiliteit)controles, veranderingen in default waarden, etc). Denk aan de wet van Hyrum.Het zou nuttig zijn om helderheid te scheppen in de betekenis van versienummers en praktische tips te geven. Moet ik de versie van mijn process API aanpassen als de versie van een van de onderliggende system API's verandert? Moet ik de versie van mijn API veranderen als er een PDF bijlage kan worden verstuurd waarvan ik nu ga afdwingen dat deze aan de PDF/A specificatie voldoet? Wat doe ik met mijn versie als ik aanvankelijk alleen JSON als content type toestond, maar nu ook XML toesta? Etc.|  |  |
|5.3.3|Ik meen een mismatch te zien tussen de genoemde subcategorieën en de paragrafen waarin ze worden uitgewerkt. Alleen de eerste ("Mediatie & Orkestratie") komt overeen.|  |  |
|5.3.3.6|Content negotiation is inmiddels een standaard practice om consumers op maat te kunnen bedienen. De API Gateway kan inderdaad de transformatie uitvoeren, maar dat vereist meestal wel een specificatie (b.v. XSLT) die als onderdeel van de API onderhouden moet worden.|  |  |
|5.2.1|Kan een interne API niet ook gesloten zijn? Niet alle medewerkers van een organisatie mogen immers mogelijk gebrfuik maken van alle diensten. Dit is natuurlijk afhankelijk van wat je onder een organisatie verstaat. Een afdeling die als geheel bij gegevens mag of een overkoepelende organisatie waar die afdeling inderdeel van uitmaakt. |  |Huidige indeling is vooral het externe klant/business perspectief,  API als product. Een onderscheid interne API's in open/gesloten is mogelijk -   |
|5.3.1.2|anmenen' --> 'afnemen'|  | verwerkt |
|5.3.2.1|In de laatste alinea staat er 1 keer 'opgenomen' te veel.|  | verwerkt |
|5.3.2.2|Hierbij moet rekening gehouden worden dat ...' --> 'Hierbij moet er rekening mee gehouden worden dat ...'Wellicht kun je aan het einde van deze paragraaf nog als nadeel van code generatie vermelden dat daarmee enkele OAS3 constructies (nog) niet gebruikt kunnen worden aangezien die fouten geven bij code generatie.|  |  |
|5.3.2.4|Kan het bij het vertalen van JSON berichten niet ook gaan om delen van die berichten? Bijv. het vertalen van alleen de geometrie gegevens.|  |  |
|5.3.2.5|Hieronder vallen denk ik ook processen om de voor de API (standaarden) aanbiedende/creerende organisatie geldende afspraken en richtlijnen (Design Rules) te verheffen naar landelijk niveau.\N.m.m. belangrijk omdat daarmee API (standaarden) aanbiedende/creerende organisatie van elkaar kunnen leren en elkaar helpen met het steeds verder verhogen van de kwaliteit van de API (standaarden).|  |  |
|5.3.2.7|braking' --> 'breaking'|  | verwerkt |
|5.3.3.3|waarabij' --> 'waarbij'|  | verwerkt |
|5.3.3.4|etrokkenen' --> 'betrokkenen'|  | verwerkt |
|5.3.3.7|inicht' --> 'inzicht'|  |verwerkt  |
|5.3.3.13|fijnazig' --> 'fijnmazig'|  | verwerkt |
|5.5.1 |We onderscheiden vier niveaus in variërend van een ...' --> 'We onderscheiden vier niveaus variërend van een ...'|  | verwerkt |
|5.5.3 (Ontkoppeling)|Het Resource mode is hier dan een abstraherende laag ...' --> 'Het Resource model is hier dan een abstraherende laag ...'|  | verwerkt |

